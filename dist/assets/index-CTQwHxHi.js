import{addButtonLeftJustified as Te}from"https://webgpufundamentals.org/webgpu/resources/js/gui-helpers.js";import{v as Re,a as Be,s as ye,K as je}from"./uwal-C6J7qtYI.js";import{C as Pe}from"./Cube-X1sXt6jj.js";import{b as M,a as Ue}from"./wgpu-matrix.module-3qzuEYdi.js";import{S as H,T as Q}from"./Transform-BHmizGDB.js";/**
 * @module Scene Graphs
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Scene Graphs
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-scene-graphs.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.1.0
 * @license MIT
 */(async function(V){let c;V.style.backgroundColor="#000";try{c=new(await Re.Renderer(V,"Scene Graphs",{alphaMode:"premultiplied"}))}catch(e){alert(e)}const S={min:-90,max:90,step:1,converters:GUI.converters.radToDeg},ee={min:-180,max:180,step:1,converters:GUI.converters.radToDeg},te=[.75,.75,.75,.75],[g,m,v]=[0,1,2],oe=[.5,.5,.5,1],ne=new Set([0,1,2]),ae=[1,1,1,1],d=[40,30,50],$=[10,2,2],T=4,z=[];let I=!1;const R=[];let B,x,h=0;const y=5,j=[];let P,O=0;const n={cameraRotation:Be.DegreesToRadians(-45),animate:!1,showMeshNodes:!1,showAllTransforms:!1,translation:M.zero(),rotation:M.zero(),scale:M.create(1,1,1)},w=new H("root"),f=new GUI().onChange(D),re=(e,t,o)=>(t-e)*o+e;f.add(n,"cameraRotation",ee),f.add(n,"animate").onChange(e=>i.enable(!e)),f.add(n,"showMeshNodes").onChange(J),f.add(n,"showAllTransforms").onChange(K);const i=f.addFolder("Orientation");i.onChange(he);const se=[i.add(n.translation,"0",-200,200,1).name("Translation X"),i.add(n.translation,"1",-200,200,1).name("Translation Y"),i.add(n.translation,"2",-200,200,1).name("Translation Z"),i.add(n.rotation,"0",S).name("Rotation X"),i.add(n.rotation,"1",S).name("Rotation Y"),i.add(n.rotation,"2",S).name("Rotation Z"),i.add(n.scale,"0",.1,100).name("Scale X"),i.add(n.scale,"1",.1,100).name("Scale Y"),i.add(n.scale,"2",.1,100).name("Scale Z")],ie=[0,d[m]/3*2-d[m]/2,$[v]/2+d[v]/2],W=d[g]+10,F=d[m]+3,U=[d[g]+6,F*T+6,d[v]+4],l=new ye(60,1,2e3);let E=l.UpdateViewProjection();const ce=(U[g]+W)/2*(y-1)/2+4;c.CreatePassDescriptor(c.CreateColorAttachment(),c.CreateDepthStencilAttachment());const C=new je,r=new c.Pipeline,L=r.CreateShaderModule(Pe),de=(T*2+1)*y+1,{layout:le,buffer:X}=r.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);C.SetRenderPipeline(await c.AddPipeline(r,{primitive:{cullMode:"back"},fragment:r.CreateFragmentState(L),depthStencil:r.CreateDepthStencilState(),vertex:r.CreateVertexState(L,void 0,[C.GetPositionBufferLayout(r),le])}));const fe=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],Y=C.UV.length/2,A=new Uint8Array(Y*4);for(let e=0,t=0;e<Y;t=(++e/4|0)*3){const o=fe.slice(t,t+3);A.set(o,e*4),A[e*4+3]=255}r.WriteBuffer(X,A),C.AddVertexBuffers(X);for(let e=0;e<y;++e)we(w,e);const ue=f.addFolder("Nodes"),me=k(ue,w);Z(w.Children[0]),K(!1),J(!1);function k(e,t,o,a){const s=[],u=a===void 0;if(t.Transform instanceof Q){const p=`${u?"":`${a} +-`}${t.Label}`;s.push(Te(e,p,()=>Z(t)))}return a=u?"":`${a}${o?"   ":" | "}`,s.push(...t.Children.map((p,b)=>k(e,p,b===t.Children.length-1,a))),s.flat()}function he(){const e=P.Transform;e.Translation.set(n.translation),e.Rotation.set(n.rotation),e.Scale.set(n.scale)}function q(){const e=P.Transform;n.translation.set(e.Translation),n.rotation.set(e.Rotation),n.scale.set(e.Scale),i.updateDisplay()}function Z(e){P=e,i.name(`Orientation: ${e.Label}`),q()}function K(e){se.forEach((t,o)=>t.show(e||ne.has(o)))}function J(e){for(const t of me)t.domElement.textContent.includes("mesh")&&t.show(e)}function G(e,t,o){const a=new H(e,new Q(...o));return t&&(a.Parent=t),a}function N(e,t,o,a){const s=G(e,t,o),u=j.push({node:s,color:a});return j[u-1]}function pe(e,t){const o=`drawer${t}`,a=U[m]/2-d[m]/2-5,s=G(o,e,[[0,F*t-a,3]]);z.push(s),N(`${o}-drawer-mesh`,s,[void 0,void 0,d],ae),N(`${o}-handle-mesh`,s,[ie,void 0,$],oe)}function we(e,t){const o=`cabinet${t}`,a=G(o,e,[[t*W,0,0]]);N(`${o}-mesh`,a,[void 0,void 0,U],te);for(let s=0;s<T;++s)pe(a,s)}function Ce(e,t){if(h===R.length){const{projection:p,buffer:b}=r.CreateUniformBuffer("projection"),{color:ve,buffer:_}=r.CreateUniformBuffer("color");r.AddBindGroups(r.CreateBindGroup(r.CreateBindGroupEntries([_,b]))),R.push({projectionValue:p,projectionBuffer:b,colorValue:ve,colorBuffer:_})}const{projectionValue:o,projectionBuffer:a,colorValue:s,colorBuffer:u}=R[h];s.set(t),r.WriteBuffer(u,s),Ue.multiply(E,e,o),r.WriteBuffer(a,o),r.SetActiveBindGroups(h),h=++h%de,c.Render(!1)}function D(){B||(B=requestAnimationFrame(ge))}function be(e){Ce(e.node.WorldMatrix,e.color)}function Se(){z.forEach((e,t)=>e.Transform.Translation[2]=re(3,d[2]*.8,Math.sin(O+t)*.5+.5))}function ge(){B=void 0,l.ResetMatrix(),l.Translate([ce,20,0]),l.RotateY(n.cameraRotation),l.Translate([0,0,300]),E=l.UpdateViewProjection(),w.UpdateWorldMatrix();for(const a of j)be(a);c.Submit();const e=n.animate,t=performance.now()*.001,o=I&&t-x||0;x=t,e&&(O+=o),I=e,n.animate&&(Se(),q(),D())}new ResizeObserver(e=>{for(const t of e){const{inlineSize:o,blockSize:a}=t.contentBoxSize[0];c.SetCanvasSize(o,a),l.AspectRatio=c.AspectRatio,l.UpdateViewProjection()}D()}).observe(document.body)})(document.getElementById("lesson"));
