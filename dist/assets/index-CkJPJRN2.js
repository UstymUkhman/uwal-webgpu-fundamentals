import{v as N,G as k,j as g,u as x,s as J}from"./uwal-BNRo3Xsn.js";class S{#o=0;#r=0;#e=0;#t=[];constructor(e=30){this.#o=e}addSample(e){if(Number.isFinite(e)&&!Number.isNaN(e)&&0<=e){const l=this.#t[this.#e]||0;this.#r+=e-l,this.#t[this.#e]=e,this.#e=(this.#e+1)%this.#o}}get(){return this.#r/this.#t.length}}var Q="struct VertexOutput{@builtin(position)position: vec4f,@location(0)color: vec4f};@vertex fn vertex(@location(0)position: vec2f,@location(1)color: vec4f,@location(2)offset: vec2f,@location(3)scale: vec2f,@location(4)vertexColor: vec4f)->VertexOutput{var output: VertexOutput;let clipSpace=GetVertexClipSpace(position*scale).xy;output.position=vec4f(clipSpace+(offset+0.9)/1.8*vec2f(2,-2),0.0,1.0);output.color=color*vertexColor;return output;}@fragment fn fragment(@location(0)color: vec4f)->@location(0)vec4f {return color;}";/**
 * @module Timing Performance
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Timing Performance
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-timing.html}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 * @version 0.0.9
 * @license MIT
 */(async function(C){let e,l=0;try{await N.SetRequiredFeatures("timestamp-query"),e=new(await N.RenderPipeline(C,"Timing Performance"))}catch(t){alert(t)}const p=24,L=0,O=0,U=2,q=new GUI,b=[],a=1e4,m={objects:100};q.add(m,"objects",0,a,1);const n=document.createElement("pre"),h=document.createElement("span"),w=document.createElement("span"),A=document.createElement("span");n.style.backgroundColor="rgb(0 0 0 / 0.8)",n.style.position="absolute",n.style.padding="0.5em",n.style.display="grid",n.style.color="white",n.style.margin="0px",n.style.left="0px",n.style.top="0px",n.append(h,w,A),document.body.appendChild(n);const B=new S,V=new S,E=new S,z=e.CreateShaderModule([k.ShapeVertex,Q]),F=e.CreateColorAttachment();F.clearValue=new g(5000268).rgba;const v=new x.LegacyGPUTiming(e),M=await v.QuerySet;e.CreatePassDescriptor(F,void 0,void 0,void 0,e.CreateTimestampWrites(M,0,1));const W=e.CreateVertexBufferLayout("position"),{buffer:u,layout:$}=e.CreateVertexBuffer([{name:"color",format:"unorm8x4"}],a,"instance"),{buffer:d,layout:D}=e.CreateVertexBuffer(["offset","scale"],a,"instance"),{buffer:R,layout:I}=e.CreateVertexBuffer({name:"vertexColor",format:"unorm8x4"},a);e.CreatePipeline({fragment:e.CreateFragmentState(z),vertex:e.CreateVertexState(z,void 0,[W,$,D,I])});const _=new J({renderer:e,innerRadius:120,radius:240,segments:p}).Update().Vertices,y=new Float32Array(d.size/Float32Array.BYTES_PER_ELEMENT);e.AddVertexBuffers([u,d,R]);{const t=u.size/a,o=new Uint8Array(u.size);for(let r=0;r<a;++r)o.set([c(255),c(255),c(255),255],t*r+L),b.push({scale:c(.2,.5),offset:[c(-.9,.9),c(-.9,.9)],velocity:[c(-.1,.1),c(-.1,.1)]});e.WriteBuffer(u,o)}{const t=new g(1644825),o=new g(16777215),r=new Uint8Array((p+1)*8);for(let i=0,s=0;i<=p;i++,s+=8)r.set(t.RGBA,s),r.set(o.RGBA,s+4);e.WriteBuffer(R,r)}function c(t,o){return t===void 0?(t=0,o=1):o===void 0&&(o=t,t=0),Math.random()*(o-t)+t}async function j(t){t*=.001;const o=t-l,r=performance.now(),i=d.size/a/4;for(let s=0;s<m.objects;s++){const{scale:P,offset:f,velocity:T}=b[s];f[0]=x.EuclideanModulo(f[0]+T[0]*o+1.5,3)-1.5,f[1]=x.EuclideanModulo(f[1]+T[1]*o+1.5,3)-1.5;const G=s*i;y.set(f,G+O),y.set([P,P],G+U)}e.WriteBuffer(d,y),e.Render([_,m.objects],!1),e.DestroyCurrentPass(),B.addSample(1/o),E.addSample(performance.now()-r),v.ResolveAndSubmit().then(s=>V.addSample(s/1e3)),h.textContent=`FPS: ${B.get().toFixed(1)}`,A.textContent=`JS: ${E.get().toFixed(1)}ms`,w.textContent=`GPU: ${v.Enabled&&`${V.get().toFixed(1)}Âµs`||"N/A"}`,requestAnimationFrame(j),l=t}new ResizeObserver(t=>{for(const o of t){const{inlineSize:r,blockSize:i}=o.contentBoxSize[0];e.SetCanvasSize(r,i)}requestAnimationFrame(j)}).observe(document.body)})(document.getElementById("lesson"));
