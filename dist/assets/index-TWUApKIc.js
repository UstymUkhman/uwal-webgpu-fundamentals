import{v as Z,a as y,s as _,K as q}from"./uwal-C6J7qtYI.js";import{M as H}from"./MatrixStack-Byml2Hz5.js";import{c as J}from"./ConeVertices-DQO7wRFY.js";import{C as N}from"./Cube-X1sXt6jj.js";import{b as Q,a as T}from"./wgpu-matrix.module-3qzuEYdi.js";/**
 * @module Recursive Tree
 * @author Ustym Ukhman <ustym.ukhman@gmail.com>
 * @description This lesson is reproduced from WebGPU Matrix Stacks
 * {@link https://webgpufundamentals.org/webgpu/lessons/webgpu-matrix-stacks.html#a-recursive-tree}&nbsp;
 * and developed by using a version listed below. Please note that this code
 * may be simplified in future thanks to more recent library APIs.
 *
 * This approach uses one render pipeline with different vertex buffers and `DrawMethods` and switches
 * between them at render time using `Pipeline.SetVertexBuffers` and `Pipeline.SetIndexBuffer` methods.
 * @version 0.1.0
 * @license MIT
 */(async function(b){let r;b.style.backgroundColor="#000";try{r=new(await Z.Renderer(b,"Recursive Tree",{alphaMode:"premultiplied"}))}catch(t){alert(t)}const c={rotationX:y.DegreesToRadians(20),rotationY:y.DegreesToRadians(10),baseRotation:0,scale:.9},A={min:-180,max:180,step:1,converters:GUI.converters.radToDeg},C={min:0,max:90,step:1,converters:GUI.converters.radToDeg},v=[20,150,20],G=[1,1,1,1],p=[],I=6;let f=0;const a=new H,u=new GUI().onChange(P);u.add(c,"scale",.1,1.2),u.add(c,"rotationX",C),u.add(c,"rotationY",C),u.add(c,"baseRotation",A);const s=new _(60,1,2e3);s.Position=[0,450,1e3],s.LookAt([0,450,0]);const U=s.UpdateViewProjection(!1);r.CreatePassDescriptor(r.CreateColorAttachment(),r.CreateDepthStencilAttachment());const l=new q,e=new r.Pipeline,x=e.CreateShaderModule(N),{layout:k,buffer:S}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},36);l.SetRenderPipeline(await r.AddPipeline(e,{primitive:{cullMode:"back"},fragment:e.CreateFragmentState(x),depthStencil:e.CreateDepthStencilState(),vertex:e.CreateVertexState(x,void 0,[l.GetPositionBufferLayout(e),k])}));const z=[200,200,70,90,130,110,70,200,210,160,160,220,200,70,120,80,70,200],V=l.UV.length/2,m=new Uint8Array(V*4);for(let t=0,o=0;t<V;o=(++t/4|0)*3){const n=z.slice(o,o+3);m.set(n,t*4),m[t*4+3]=255}const{vertexData:h,colorData:M,vertices:O}=J(20,60),w=e.CreateVertexBuffer(h),{buffer:R}=e.CreateVertexBuffer({name:"color",format:"unorm8x4"},O);e.WriteBuffer(R,M),e.WriteBuffer(w,h),e.WriteBuffer(S,m),l.AddVertexBuffers(S);const W=[w,R],Y=Object.values(e.IndexBuffer),L=e.VertexBuffers.map(({buffer:t})=>t);function g(t,o){if(f===p.length){const{projection:K,buffer:D}=e.CreateUniformBuffer("projection"),{color:F,buffer:j}=e.CreateUniformBuffer("color");e.AddBindGroups(e.CreateBindGroup(e.CreateBindGroupEntries([j,D]))),p.push({projectionValue:K,projectionBuffer:D,colorValue:F,colorBuffer:j})}const{projectionValue:n,projectionBuffer:i,colorValue:d,colorBuffer:E}=p[f];d.set(G),e.WriteBuffer(E,d),T.multiply(U,t,n),e.WriteBuffer(i,n),e.SetVertexBuffers(o?W:L),e.SetIndexBuffer(...!o&&Y||[void 0]),e.SetActiveBindGroups(f++),r.Render(!1)}function X(){a.Push().Scale(v).Translate([0,.5,0]),g(a.Get()),a.Pop()}function B(t,o){const n=t?c.scale:1,i=t?v[1]:0;if(a.Push().Translate([0,i,0]).RotateZ(t*c.rotationX).RotateY(Math.abs(t)*c.rotationY).Scale([n,n,n]),X(),0<o&&(B(-1,o-1),B(1,o-1)),0<t&&!o){const d=Q.getTranslation(a.Get());g(T.translation(d),!0)}a.Pop()}function P(){a.Push(),a.RotateY(c.baseRotation),f=0,B(0,I),a.Pop(),r.Submit()}new ResizeObserver(t=>{for(const o of t){const{inlineSize:n,blockSize:i}=o.contentBoxSize[0];r.SetCanvasSize(n,i),s.AspectRatio=r.AspectRatio,s.UpdateViewProjection(!1)}P()}).observe(document.body)})(document.getElementById("lesson"));
